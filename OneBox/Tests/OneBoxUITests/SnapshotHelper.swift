//
//  SnapshotHelper.swift
//  Official fastlane snapshot helper
//
//  Created by Felix Krause on 10/8/15.
//  Copyright Â© 2015 Felix Krause. All rights reserved.
//

// -----------------------------------------------------
// IMPORTANT: This file is auto-generated by fastlane snapshot
// It should be placed in your UI Tests target
// -----------------------------------------------------

import Foundation
import XCTest

var deviceLanguage = ""
var locale = ""

func setupSnapshot(_ app: XCUIApplication, waitForAnimations: Bool = true) {
    Snapshot.setupSnapshot(app, waitForAnimations: waitForAnimations)
}

func snapshot(_ name: String, waitForLoadingIndicator: Bool = true) {
    if waitForLoadingIndicator {
        Snapshot.snapshot(name, timeWaitingForIdle: 20)
    } else {
        Snapshot.snapshot(name, timeWaitingForIdle: 0)
    }
}

enum SnapshotError: Error, CustomDebugStringConvertible {
    case cannotFindSimulatorHomeDirectory
    case cannotRunOnPhysicalDevice

    var debugDescription: String {
        switch self {
        case .cannotFindSimulatorHomeDirectory:
            return "Couldn't find simulator home directory"
        case .cannotRunOnPhysicalDevice:
            return "Running on physical device. Snapshot requires a simulator."
        }
    }
}

@objcMembers
open class Snapshot: NSObject {
    static var app: XCUIApplication?
    static var waitForAnimations = true
    static var cacheDirectory: URL?
    static var screenshotsDirectory: URL? {
        return cacheDirectory
    }

    open class func setupSnapshot(_ app: XCUIApplication, waitForAnimations: Bool = true) {

        Snapshot.app = app
        Snapshot.waitForAnimations = waitForAnimations

        do {
            let cacheDir = try getCacheDirectory()
            Snapshot.cacheDirectory = cacheDir
            setLanguage(app)
            setLocale(app)
            setLaunchArguments(app)
        } catch {
            NSLog("Snapshot: Error setting up snapshot: \(error)")
        }
    }

    class func setLanguage(_ app: XCUIApplication) {
        let path = getCacheDirectory()?.appendingPathComponent("language.txt")

        do {
            if let path = path {
                let trimCharacterSet = CharacterSet.whitespacesAndNewlines
                deviceLanguage = try String(contentsOf: path, encoding: .utf8).trimmingCharacters(in: trimCharacterSet)
                app.launchArguments += ["-AppleLanguages", "(\(deviceLanguage))"]
            }
        } catch {
            NSLog("Snapshot: Couldn't detect/set language: \(error)")
        }
    }

    class func setLocale(_ app: XCUIApplication) {
        let path = getCacheDirectory()?.appendingPathComponent("locale.txt")

        do {
            if let path = path {
                let trimCharacterSet = CharacterSet.whitespacesAndNewlines
                locale = try String(contentsOf: path, encoding: .utf8).trimmingCharacters(in: trimCharacterSet)
                app.launchArguments += ["-AppleLocale", "\"\(locale)\""]
            }
        } catch {
            NSLog("Snapshot: Couldn't detect/set locale: \(error)")
        }
    }

    class func setLaunchArguments(_ app: XCUIApplication) {
        let path = getCacheDirectory()?.appendingPathComponent("snapshot-launch_arguments.txt")

        if let path = path, let launchArguments = try? String(contentsOf: path, encoding: .utf8) {
            let trimCharacterSet = CharacterSet.whitespacesAndNewlines
            let splitArguments = launchArguments.components(separatedBy: "\n")
            let arguments = splitArguments.map { $0.trimmingCharacters(in: trimCharacterSet) }
            app.launchArguments += arguments
        }
    }

    open class func snapshot(_ name: String, timeWaitingForIdle timeout: TimeInterval = 20) {
        if timeout > 0 {
            waitForLoadingIndicatorToDisappear(within: timeout)
        }

        NSLog("Snapshot: Taking snapshot '\(name)'")

        sleep(1) // Allow UI to settle

        guard let app = Snapshot.app else {
            NSLog("Snapshot: App not set up. Call setupSnapshot() first.")
            return
        }

        let screenshot = app.screenshot()
        guard var cacheDir = self.cacheDirectory else {
            NSLog("Snapshot: No cache directory available")
            return
        }

        do {
            // Append language folder
            cacheDir.appendPathComponent(deviceLanguage.isEmpty ? Locale.current.identifier : deviceLanguage)
            try FileManager.default.createDirectory(at: cacheDir, withIntermediateDirectories: true)

            let fileURL = cacheDir.appendingPathComponent("\(name).png")
            try screenshot.pngRepresentation.write(to: fileURL)
            NSLog("Snapshot: Saved '\(name)' to \(fileURL.path)")
        } catch {
            NSLog("Snapshot: Failed to save \(name): \(error)")
        }
    }

    class func waitForLoadingIndicatorToDisappear(within timeout: TimeInterval) {
        guard let app = Snapshot.app else { return }

        let networkLoadingIndicator = app.otherElements.deviceStatusBars.networkLoadingIndicators.element
        let loadingIndicator = app.activityIndicators.element

        // Wait for network and activity indicators to disappear
        _ = networkLoadingIndicator.waitForDisappearance(within: timeout)
        _ = loadingIndicator.waitForDisappearance(within: timeout)
    }

    class func getCacheDirectory() throws -> URL? {
        #if targetEnvironment(simulator)
        guard let simulatorHostHome = ProcessInfo.processInfo.environment["SIMULATOR_HOST_HOME"] else {
            throw SnapshotError.cannotFindSimulatorHomeDirectory
        }
        let homeDir = URL(fileURLWithPath: simulatorHostHome)
        return homeDir.appendingPathComponent("Library/Caches/tools.fastlane")
        #else
        throw SnapshotError.cannotRunOnPhysicalDevice
        #endif
    }
}

// MARK: - Extensions

extension XCUIElement {
    var isLoadingIndicator: Bool {
        let dominated = frame.size.width < 60 && frame.size.height < 60
        return dominated
    }

    func waitForDisappearance(within timeout: TimeInterval) -> Bool {
        let start = Date()
        while Date().timeIntervalSince(start) < timeout {
            if !exists || !isHittable {
                return true
            }
            RunLoop.current.run(until: Date(timeIntervalSinceNow: 0.5))
        }
        return false
    }
}

extension XCUIElementQuery {
    var networkLoadingIndicators: XCUIElementQuery {
        let isNetworkLoadingIndicator = NSPredicate { (evaluatedObject, _) in
            guard let element = evaluatedObject as? XCUIElementAttributes else { return false }
            return element.identifier == "network"
        }
        return self.containing(isNetworkLoadingIndicator)
    }

    var deviceStatusBars: XCUIElementQuery {
        let isStatusBar = NSPredicate { (evaluatedObject, _) in
            guard let element = evaluatedObject as? XCUIElementAttributes else { return false }
            return element.elementType == .statusBar
        }
        return self.containing(isStatusBar)
    }
}
